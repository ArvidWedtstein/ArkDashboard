import clsx from "clsx"
import { useMemo, useState } from "react";
import Button from "../Button/Button";

interface GridValidRowModel {
  [key: string]: any
}
type GridColumns<R extends GridValidRowModel = any> = GridEnrichedColDef<R>[];
interface GridRowParams<R extends GridValidRowModel = any> {
  /**
   * The grid row id.
   */
  id: GridRowId;
  /**
   * The row model of the row that the current cell belongs to.
   */
  row: R;
  /**
   * All grid columns.
   */
  columns: GridColumns;
}
interface GridActionsColDef<R extends GridValidRowModel = any, V = any, F = V> extends GridColumnDef<R, V, F> {
  /**
   * Type allows to merge this object with a default definition [[GridColumn]].
   * @default 'actions'
   */
  type: 'actions';
  /**
   * Function that returns the actions to be shown.
   * @param {GridRowParams} params The params for each row.
   * @returns {React.ReactElement<GridActionsCellItemProps>[]} An array of [[GridActionsCell]] elements.
   */
  getActions: (params: GridRowParams<R>) => React.ReactElement<any>[];
}
type GridRowModel<R extends GridValidRowModel = GridValidRowModel> = R;
export interface GridValueGetterParams<V = any, R extends GridValidRowModel = GridValidRowModel> extends Omit<GridCellParams<V, R, any>, 'formattedValue' | 'isEditable'> {
  /**
   * The default value for the cell that the `valueGetter` is overriding.
   */
  value: GridCellParams<V, R, any>['value'];
}
type GridKeyValue = string | number | boolean;
type GridEnrichedColDef<R extends GridValidRowModel = any, V = any, F = V> = GridColumnDef<R, V, F> | GridActionsColDef<R, V, F>
interface GridRowTreeNodeConfig {
  /**
   * The grid row id.
   */
  id: GridRowId;
  /**
   * The id of the row children.
   * @default []
   */
  children?: GridRowId[];
  /**
   * The id of the footer
   */
  footerId?: GridRowId | null;
  /**
   * The row id of the parent (null if this row is a top level row).
   */
  parent: GridRowId | null;
  /**
   * Current expansion status of the row.
   * @default false
   */
  childrenExpanded?: boolean;
  /**
   * 0-based depth of the row in the tree.
   */
  depth: number;
  /**
   * The key used to group the children of this row.
   */
  groupingKey: GridKeyValue | null;
  /**
   * The field used to group the children of this row.
   * Is `null` if no field has been used to group the children of this row.
   */
  groupingField: string | null;
  /**
   * If `true`, this node has been automatically added to fill a gap in the tree structure.
   * @default false
   */
  isAutoGenerated?: boolean;
  /**
   * Position of the row among its sibling.
   * @default 'body'
   */
  position?: 'body' | 'footer';
  /**
   * If `true`, this row is pinned.
   * @default false
   */
  isPinned?: boolean;
}
type GridStateColDef<R extends GridValidRowModel = any, V = any, F = V> = GridEnrichedColDef<R, V, F> & {
  computedWidth: number;
  /**
   * If `true`, it means that at least one of the dimension's property of this column has been modified since the last time the column prop has changed.
   */
  hasBeenResized?: boolean;
};
interface GridCellParams<V = any, R extends GridValidRowModel = any, F = V> {
  /**
   * The grid row id.
   */
  id: GridRowId;
  /**
   * The column field of the cell that triggered the event.
   */
  field: string;
  /**
   * The cell value.
   * If the column has `valueGetter`, use `params.row` to directly access the fields.
   */
  value?: V | undefined;
  /**
   * The cell value formatted with the column valueFormatter.
   */
  formattedValue?: F | undefined;
  /**
   * The row model of the row that the current cell belongs to.
   */
  row: GridRowModel<R>;
  /**
   * The node of the row that the current cell belongs to.
   */
  rowNode: GridRowTreeNodeConfig;
  /**
   * The column of the row that the current cell belongs to.
   */
  colDef: GridStateColDef;
  /**
   * If true, the cell is the active element.
   */
  hasFocus: boolean;
  /**
   * the tabIndex value.
   */
  tabIndex: 0 | -1;
}
type GridRowId = string | number;
type GridColumnTypes = 'string' | 'number' | 'date' | 'dateTime' | 'boolean' | 'singleSelect' | 'actions';
interface GridValueFormatterParams<V = any> {
  /**
   * The grid row id.
   * It is not available when the value formatter is called by the filter panel.
   */
  id?: GridRowId;
  /**
   * The column field of the cell that triggered the event.
   */
  field: string;
  /**
   * The cell value, if the column has valueGetter it is the value returned by it.
   */
  value: V;
}

type GridRowsProp<R extends GridValidRowModel = GridValidRowModel> = Readonly<GridRowModel<R>[]>
export interface GridColumnDef<R extends GridValidRowModel = any, V = any, F = V> {
  field: string;
  headerName?: string;
  description?: string;
  width?: number;
  hide?: boolean;
  sortable?: boolean;
  sortingOrder?: 'asc' | 'desc' | null | undefined;
  resizable?: boolean;
  type?: GridColumnTypes;
  align?: 'left' | 'center' | 'right';
  valueGetter?: (params: GridValueGetterParams<any, R>) => V;
  valueFormatter?: (params: GridValueFormatterParams<V>) => F;
  renderCell?: (params: GridCellParams<V, R, F>) => React.ReactNode;
}
interface DataGridProps<R extends GridValidRowModel = any> {
  columns: GridColumns<R>;
  rows: GridRowsProp<R>;
  select?: boolean;
}
const Datagrid = (props: DataGridProps) => {
  const {
    columns,
    rows,
    select = false
  } = props;

  const [resizingColumn, setResizingColumn] = useState(null);
  const [pageX, setPageX] = useState(null);
  const [columnState, setColumnState] = useState(columns);

  const handleMouseDown = (e: React.MouseEvent, field) => {
    setResizingColumn(field);
    setPageX(e.pageX);
  }

  const handleMouseUp = () => {
    setResizingColumn(null)
    setPageX(0)
  }

  const handleMouseMove = (event: React.MouseEvent, field: string) => {

    if (resizingColumn) {

      const newWidth = event.pageX - pageX;
      setColumnState((prevColumns) => {
        return prevColumns.map((col) => {
          return {
            ...col,
            width: col.field === field ? newWidth : col.width
          }
        })
      })
    }
  }

  const calculateField = <R extends GridValidRowModel>(
    row: R,
    column: GridColumnDef<R>
  ): React.ReactNode => {
    let value = column.valueGetter ?
      column.valueGetter({
        id: row.id,
        field: column.field,
        value: row[column.field],
        row,
        rowNode: {
          id: 1,
          groupingField: '',
          depth: 0,
          footerId: '',
          parent: null,
          children: null,
          childrenExpanded: false,
          groupingKey: '',
          isAutoGenerated: false,
        },
        hasFocus: false,
        tabIndex: 0,
        colDef: {
          ...column,
          computedWidth: 100,
          hasBeenResized: false
        }
      }) : row[column.field];
    if (column.renderCell) {
      return column.renderCell({
        id: row.id,
        field: column.field,
        value,
        formattedValue: column.valueFormatter ? column.valueFormatter({
          field: column.field,
          id: row.id,
          value: value
        }) : value,
        row,
        rowNode: {
          id: 1,
          groupingField: '',
          depth: 0,
          footerId: '',
          parent: null,
          children: null,
          childrenExpanded: false,
          groupingKey: '',
          isAutoGenerated: false,
        },
        hasFocus: false,
        tabIndex: 0,
        colDef: {
          ...column,
          computedWidth: 100,
          hasBeenResized: false
        }
      })
    }

    return value
  }

  const classes = {
    DataGridRoot: clsx("relative flex flex-col outline-0 box-border rounded border border-zinc-500 dark:text-white text-black"),
    DataGridMain: clsx("relative flex-grow flex flex-col overflow-hidden"),
    DataGridFooter: clsx("flex justify-between min-h-[3rem]"),
    DataGridColumnHeaders: clsx("flex relative items-center box-border border-b border-zinc-500 rounded-t"),
    DataGridColumnHeadersInner: clsx("flex items-start flex-col"),
    DataGridColumnHeader: clsx("relative flex items-center box-border px-2.5 font-medium focus:outline focus:outline-pea-500"),
    DataGridColumnCheckbox: clsx("!p-0 justify-center"),
    DataGridColumnHeaderTitle: clsx("overflow-hidden whitespace-nowrap text-ellipsis"),
    DataGridColumnHeaderTitleContainer: clsx("flex items-center min-w-0 relative overflow-hidden whitespace-nowrap flex-1"),
    DataGridColumnHeaderTitleContainerContent: clsx("flex items-center overflow-hidden"),
    DataGridCell: clsx("overflow-hidden justify-start flex items-center border-b border-zinc-500 px-2.5 box-border"),
    DataGridCellLeft: clsx("justify-start"),
    DataGridCellRight: clsx("justify-end"),
    DataGridCellCenter: clsx("justify-center"),
    DataGridCellContent: clsx("overflow-hidden text-ellipsis whitespace-nowrap"),
  }
  return (
    <div className={classes.DataGridRoot}>
      <div className={classes.DataGridMain}>
        <div className={clsx(classes.DataGridColumnHeaders, "group/headers")} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onMouseMove={(e) => handleMouseMove(e, resizingColumn)} role="presentation">
          <div className={classes.DataGridColumnHeadersInner} style={{ transform: `translate3d(0px, 0px, 0px)` }}>
            <div role="row" className={"flex"} aria-rowindex={1}>

              {select && (
                <div className={clsx(classes.DataGridColumnHeader, classes.DataGridColumnCheckbox)} role="columnheader" style={{ minWidth: 48, maxWidth: 50, width: 48, height: 56 }}>
                  <div className="flex w-full h-full" role="presentation" draggable={true}>
                    <div className={clsx(classes.DataGridColumnHeaderTitleContainer, classes.DataGridCellCenter)} role="presentation">
                      <div className={clsx(classes.DataGridColumnHeaderTitleContainerContent, classes.DataGridCellCenter)} role="presentation">
                        <span className="inline-flex items-center justify-center relative box-border bg-transparent appearance-none rounded-[50%] p-2">
                          <input className="absolute top-0 left-0 m-0 p-0 z-10 w-full h-full opacity-0" type="checkbox"></input>
                          <svg className="w-5 h-5 fill-current" focusable="false" aria-hidden="true" viewBox="0 0 24 24">
                            <path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
                          </svg>
                        </span>
                      </div>
                    </div>
                  </div>
                  <div onMouseDown={(e) => handleMouseDown(e, 'select')} className="-right-3 min-h-[56px] group-hover/headers:visible cursor-col-resize touch-none absolute invisible z-50 flex flex-col justify-center text-zinc-500" aria-label="Seperator">
                    <svg className="text-current w-5 h-5 inline-block fill-current" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="SeparatorIcon">
                      <path d="M11 19V5h2v14z" />
                    </svg>
                  </div>
                </div>
              )}

              {columnState.map((col, index) => {
                return (
                  <GridColumn columnProps={col} key={index.toString()} onMouseDown={(e) => handleMouseDown(e, col.field)} />
                )
              })}

            </div>
          </div>
        </div>

        <div className="overflow-x-hidden overflow-auto relative z-0" role="presentation">
          <div className="w-auto h-60 min-h-full" role="presentation">
            <div className="absolute flex flex-col" role="rowgroup" style={{ transform: 'translate3d(0px, 0px, 0px)' }}>
              {rows.map((row, index) => {
                return (
                  <div key={`row-${index}`} className="flex w-fit break-inside-avoid max-h-12" aria-selected={false} role="row" style={{ minHeight: 52, maxHeight: 52 }}>
                    {select && (
                      <div className={clsx(classes.DataGridCell, classes.DataGridColumnCheckbox)} style={{ minWidth: 48, maxWidth: 52, minHeight: 52, maxHeight: 52 }}>
                        <span className="inline-flex items-center justify-center relative box-border bg-transparent appearance-none rounded-[50%] p-2">
                          <input className="absolute top-0 left-0 m-0 p-0 z-10 w-full h-full opacity-0" type="checkbox"></input>
                          <svg className="w-5 h-5 fill-current" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="CheckBoxIcon"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
                          </svg>
                        </span>
                      </div>
                    )}
                    {columnState.map((col, colIndex) => {
                      return (
                        <div
                          key={`row-${index}-col-${colIndex}`}
                          className={clsx(classes.DataGridCell, {
                            "justify-start": col.align === 'left',
                            "justify-center": col.align === 'center',
                            "justify-end": col.align === 'right',
                          })}
                          style={{ width: col.width || 100 }}
                        >
                          <div className={classes.DataGridCellContent}>
                            {calculateField(row, col)}
                          </div>
                        </div>
                      )
                    })}
                    {/* <div className={clsx(classes.DataGridCell, "flex-grow flex-1")} style={{}} /> */}
                  </div>
                )
              })}

              {/* <div className="flex w-fit break-inside-avoid max-h-12" aria-selected={false} role="row" style={{ minHeight: 52, maxHeight: 52 }}>
                <div className={clsx(classes.DataGridCell, classes.DataGridColumnCheckbox)} style={{ minWidth: 48, maxWidth: 52, minHeight: 48, maxHeight: 52 }}>
                  <span className="inline-flex items-center justify-center relative box-border bg-transparent appearance-none rounded-[50%] p-2">
                    <input className="absolute top-0 left-0 m-0 p-0 z-10 w-full h-full opacity-0" type="checkbox"></input>
                    <svg className="w-5 h-5 fill-current" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="CheckBoxIcon"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
                    </svg>
                  </span>
                </div>

                <div className={classes.DataGridCell} style={{ width: 103 }} />
              </div> */}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}


const GridColumn = ({ columnProps, key, onMouseDown }: {
  columnProps: GridEnrichedColDef,
  key: string,
  onMouseDown: (event) => void;
}) => {
  const { field, headerName, description, width = 100, sortable, align = 'left' } = columnProps

  const classes = {
    DataGridColumnHeaders: clsx("flex relative items-center box-border border-b border-zinc-500 rounded-t"),
    DataGridColumnHeadersInner: clsx("flex items-start flex-col"),
    DataGridColumnHeader: clsx("relative flex items-center box-border px-2.5 font-medium focus:outline focus:outline-pea-500"),
    DataGridColumnCheckbox: clsx("!p-0 justify-center"),
    DataGridColumnHeaderTitle: clsx("overflow-hidden whitespace-nowrap text-ellipsis"),
    DataGridColumnHeaderTitleContainer: clsx("flex items-center min-w-0 relative overflow-hidden whitespace-nowrap flex-1"),
    DataGridColumnHeaderTitleContainerContent: clsx("flex items-center overflow-hidden"),
    DataGridCell: clsx("overflow-hidden justify-start flex items-center border-b border-zinc-500 px-2.5 box-border"),
    DataGridCellContent: clsx("overflow-hidden text-ellipsis whitespace-nowrap"),
  }
  return (
    <div
      key={key}
      className={clsx(classes.DataGridColumnHeader, "group/column", {
        "justify-start": align === 'left',
        "justify-center": align === 'center',
        "justify-end": align === 'right',
      })}
      style={{ width: width, height: 52 }}
    >
      <div className="flex w-full h-full" role="presentation" draggable="false">
        <div className={classes.DataGridColumnHeaderTitleContainer} role="presentation">
          <div className={classes.DataGridColumnHeaderTitleContainerContent} role="presentation">
            <div className={classes.DataGridColumnHeaderTitle}>
              {headerName || field}
            </div>
          </div>
          <div className={clsx("flex w-0 invisible group-hover/column:visible")} aria-label="Sort Icon">
            <Button variant="icon" color="DEFAULT" size="small">
              <svg className="" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="ArrowUpwardIcon">
                <path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z" />
              </svg>
            </Button>
          </div>
        </div>
        <div aria-label="Icon Menu">

        </div>
      </div>
      <div onMouseDown={onMouseDown} className="-right-3 min-h-[56px] group-hover/headers:visible cursor-col-resize touch-none absolute invisible z-50 flex flex-col justify-center text-zinc-500" aria-label="Seperator">
        <svg className="text-current w-5 h-5 inline-block fill-current" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="SeparatorIcon">
          <path d="M11 19V5h2v14z" />
        </svg>
      </div>
    </div>
  )
}

export default Datagrid
